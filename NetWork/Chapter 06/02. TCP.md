## 📕 Chapter 06 전송 계층(TCP)
### 📙 02 TCP
</br>

💡 TCP

    ◼️ TCP는 연결 지향형 프로토콜로 데이터 교환 전 TCP 연결을 확립해야 함
    ◼️ 데이터의 수신, 오류 발생 여부를 알려주는 신뢰성 있는 데이터 전송을 제공
    ◼️ 분할한 데이터를 순차적으로 전송
</br>

💡  TCP 연결형 데이터 서비스
<p align="center"><img src="https://user-images.githubusercontent.com/45066381/154902459-00e8b345-0fb8-4c5c-89e5-632f6219638a.png" width="500" height="300"/></p>

    TCP 전송 계층은 송신 측 TCP 포트에서 수신 측 TCP 포트로 바이트 스트림을 전송하는 연결형 데이터 전송 서비스 제공
    
    양쪽의 사용자가 동시에 데이터를 전송할 수 있는 전이중 방식 ex) 전화
    
    송신자 TCP 연결 요청 -> TCP 프로토콜, 수신자 연결 설정에 동의 -> TCP 연결 확립, 통신을 종료할 때까지 연결 상태 유지
    
    신뢰성 있는 데이터를 전송하기 위해 데이터 수신 여부와 오류 발생 여부를 매번 확인한다.
</br>

💡 포트 번호

    포트는 TCP가 상위 계층으로 데이터를 전송하거나 그 반대인 경우 사용하는 데이터의 이동 통로를 의미
    -> 상위 계층과 하위 계층이 같은 포트를 사용해야만 통신 가능
    
    각 프로그램마다 다른 포트 번호를 사용하기 때문에 동시에 데이터 전송이 가능 -> 헤더에 포트 번호가 포함되어 있음
    
    데이터를 전송할 때는 수신 측의 IP 주소가 필요하지만 어떤 애플리케이션이 사용되고 있는지 구분하기 위해서는 포트 번호가 필요
    
    주요 인터넷 서비스는 이미 정해진 포트 번호가 있음 ex) HTTP : 80, DNS : 53, FTP : 21
</br>

💡 TCP 세그먼트

    TCP 프로토콜은 데이터를 전송하기 위해 바이트 스트림을 세그먼트 단위로 분할 = 스트림 기반의 전송방식
    
    TCP 세그먼트는 세션 계층이 보낸 데이터에 TCP 헤더를 붙여 구성
</br>

💡 TCP 헤더    
<p align="center"><img src="https://user-images.githubusercontent.com/45066381/154904151-4156509d-70ba-485f-b3aa-ab7339edeb81.png" width="500" height="300"/></p>
    
    ◼️ 송신지 포트 번호 : 송신지 호스트에 있는 응용 프로그램 포트 번호
    ◼️ 수신지 포트 번호 : 클라이언트가 수신지 포트를 요청하는 서버라면 수신지 포트 번호는 대부분 잘 알여진 번호
    ◼️ 순서 번호 : 전송하는 바이트마다 부여되는 순서번호(세그먼트의 첫 번째 바이트)
    ◼️ 확인 응답 번호 : 성공적으로 쉰한 마지막 바이트의 번호 +1
    ◼️ 코드 비트 : 연결 제어 정보 기록, 초깃값 0 -> 활성화 1  
                  - URG(긴급 처리 데이터)
                  - ACK(응답 확인 번호)
                  - PSH(상위 계층에 데이터 전달)
                  - RST(연결 재설정)
                  - SYN(순서 번호 동기화)
                  - FIN(송신 종료)
     ◼️ 윈도우 : 상대방이 유지해야 하는 바이트 단위의 윈도우 크기를 정의
</br>

💡 3-way 핸드셰이킹
<p align="center"><img src="https://user-images.githubusercontent.com/45066381/154905610-fdfcc59c-f373-4ad6-8d0b-ff1422e482b9.png" width="550" height="300"/></p>

    TCP 전송 방식에서 연결 확립을 위해 패킷 요청을 세 번 교환하는 과정, 각 과정에서 TCP 헤더의 코드 비트가 1로 활성화 된다.
    
    1. 송신 측 컴퓨터는 수신 측 컴퓨터에 연결 확립 허가를 위한 SYN(랜덤한 값, a) 요청
    2. 수신 측 컴퓨터는 응답을 위해 연결 확립 응답인 ACK(a+1) 전송, 송신 측 컴퓨터로부터 데이터 전송 허가를 위해 연결 확립 요청인 
       SYN(랜덤한 값, b) 전송 -> 이때 TCP 헤더의 SYN, ACK가 1로 활성화
    3. 수신 측 컴퓨터의 요청을 받은 송신 측은 연결 확립 응답인 ACK(b+1) 전송
    
    3-way HandShaking 과정이 끝나고 데이터를 전송할 때는 TCP 헤더의 순서 번호와 확인 응답 번호를 사용한다.
    순서 번호를 부여하면 수신 측은 몇 번째 데이터를 받았는지 알 수 있고, 확인 응답 번호는 수신 측이 몇 번째 데이터를 수신했는지 
    송신 측에 알려주는 용도로 사용한다. -> 신뢰성 있는 데이터 전송을 위함
</br>

💡 연결 종료

    연결을 끊을 때는 FIN과 ACK 사용
    
    1. 송신 측 컴퓨터는 연결 종료 요청(FIN) 전송
    2. 수신 측 컴퓨터는 연결 종료 응답(ACK) 전송
    3. 수신 측 컴퓨터는 송신 측 컴퓨터로 연결 종료 요청(FIN) 전송
    4. 송신 측 컴퓨터는 연결 종료 응답(ACK) 전송
</br>

💡 소켓 주소

    각 종단 프로세스를 연결하기 위해서 TCP는 IP 주소와 포트 번호가 필요, 이 두 주소의 조합을 소켓 주소라고 한다.
    TCP 서비스를 이용하기 위해서는 클라이언트 소켓 주소와 서버의 소켓 주소가 필요
</br>

💡 TCP 연결 관리
    
    3-way HandShaking 과정에서 순서 번호(SYN)와 확인 응답 번호(ACK)가 결정된다.
    순서 번호는 전송하는 데이터의 첫 번째 바이트 번호이고, 확인 응답 번호는 다음에 전송하길 바라는 데이터의 첫 번째 바이트가 된다.
    
    ex) 3-way HandShaking 과정에서 SYN:5001번, ACK:6001이 결정됐고, 300바이트 데이터를 송신한다면
    
        1. 송신 -> 수신 300 바이트 데이터 송신 => SYN : 5001, ACK : 6001
        2. 수신 -> 송신                        => SYN : 6001, ACK : 5301
        3. 송신 -> 수신 300 바이트 데이터 송신 => SYN : 5301, ACK : 6001
        4. 수신 -> 송신                        => SYN : 6001, ACK : 5601
        
        SYN은 송신하는 데이터의 첫 번째 바이트를 의미, ACK는 SYN + 데이터의 크기
</br>

💡 TCP 흐름 제어 

     TCP는 원래의 데이터를 분할해서 전송하기 때문에 수신 측이 재결합 과정을 거쳐 원래의 데이터로 복구해야 함 -> 패킷 번호 사용
     
     수신 측 컴퓨터는 패킷이 정상적으로 도착했는지 송신 측에 알리고, 송신 측은 전송되지 않은 패킷 재전송 
</br>

💡 윈도우 크기

     수신 측 컴퓨터로 한 번에 얼만큼의 데이터를 전송할 수 있는지 나타낸 것이 윈도우 크기
     
     윈도의 크기의 초깃 값은 3-way HandShaking 과정에서 서로의 값을 확인 -> 오버플로우가 발생하지 않도록 데이터 전송
</br>

💡 슬라이딩 윈도우
<p align="center"><img src="https://user-images.githubusercontent.com/45066381/154915104-25e5ed68-47e9-4fcb-9d9b-56eebad46c21.png" width="500" height="300"/></p>

     송신 측 컴퓨터가 윈도우 크기에 따라 패킷을 한 번에 전송, 수신 측이 ACK를 보내면 ACK 신호에서 요청한 패킷 위치로 송신 윈도우를 옮긴다.
     이처럼 송신 버퍼 역할을 하기 위해 송신 윈도우를 이용하는 방식을 슬라이딩 윈도우
</br></br>

📌 정리
     
     TCP 계층의 역할
     1. 흐름 제어 : 상대방이 받을 수 있을 만큼만 데이터를 효율적으로 전송 -> 슬라이딩 윈도우 사용
     2. 오류 제어 : 안전한 전송 보장, 오류 발생시 재전송
     3. 혼잡 제어 : 네트워크 혼잡 정도(데이터 손실 유무로 판단)에 따라 송신자가 데이터 전송량 제어
   
